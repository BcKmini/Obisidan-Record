### ë°œí‘œì¤€ë¹„
Slide-5 (ë‹¤ë¥¸ í”„ë ˆìž„ì›Œí¬ vs Pytorchë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ  )
- **ë™ì  ê³„ì‚° ê·¸ëž˜í”„**: ì‹¤í–‰ ì‹œì ì— ê·¸ëž˜í”„ë¥¼ ìƒì„±í•˜ê³  ìˆ˜ì • ê°€ëŠ¥, ì§ê´€ì ì¸ ë””ë²„ê¹… ë° ìœ ì—°í•œ ëª¨ë¸ ì„¤ê³„ì— ìœ ë¦¬.
    
- **Python ì¹œí™”ì **: Pythonicí•œ ë¬¸ë²•ê³¼ ì¸í„°íŽ˜ì´ìŠ¤ ì œê³µ, ë¹ ë¥´ê³  ê°„íŽ¸í•œ í”„ë¡œí† íƒ€ì´í•‘ ê°€ëŠ¥.
    
- **ì»¤ë®¤ë‹ˆí‹° ë° ìƒíƒœê³„**: í’ë¶€í•œ íŠœí† ë¦¬ì–¼, ê°•ë ¥í•œ ì»¤ë®¤ë‹ˆí‹° ì§€ì›, ë‹¤ì–‘í•œ ì˜¤í”ˆì†ŒìŠ¤ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ í†µí•©.
    
- **TorchScript**: ë™ì  ê·¸ëž˜í”„ì˜ ìž¥ì  ìœ ì§€í•˜ë©´ì„œ ëª¨ë¸ì˜ ë°°í¬ ë° ìµœì í™”ë¥¼ ì§€ì›.
    
- **GPU ì§€ì›**: CUDAë¥¼ í†µí•´ GPU ê°€ì† í•™ìŠµ ë° ì¶”ë¡ ì„ ê°„íŽ¸í•˜ê²Œ êµ¬í˜„.

---
# ðŸ“Œ Nano-Lab-Meeting

> 1ì°¨ì›ì ìœ¼ë¡œ DB_v1ì„ ì“´ê²ƒì´ ë¬¸ì œ.

ì œì¼ ì™¼ìª½ì— ìžˆëŠ” ê·¸ëž˜í”„
-> **ì‹œê³„ì—´ê·¸ëž˜í”„ë¡œ**ë¡œ ê·¸ë¦¬ê¸° ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ í‘œí˜„í•´ì•¼ ëª¨ë‘ ë³´ì¼ì§€ì— ëŒ€í•œ ê³ ë¯¼ 
(ì—†ì• ê¸°)

ì œì¼ ì˜¤ë¥¸ìª½ì— ìžˆëŠ” í‘œë¥¼ x 
ìœ„/ê²½ë„ë¥¼ ì§€ë„ì— ì°ì–´ì„œ ë³´ì—¬ì£¼ê¸° (ì¤Œì¸, ì¤Œì•„ì›ƒ)
-> devicde overview 

- ì¶”ê°€ ì‚¬í•­ì€ ë¯¸ë¦¬ ìˆ˜ì •í•˜ê³  ê·¸ë‹¤ìŒì— ë³´ê¸° 
- ë°ì´í„°ë¥¼ ì–´ë–»ê²Œ í‘œí˜„í•˜ëŠ”ê²ƒì´ ì œì¼ ì¢‹ì„ê²ƒì¸ê°€
- ìƒˆ ì¢…ë¥˜ì— ëŒ€í•œ ì •ë³´(DB)ê°€ ì—†ìŒ 

---
## ðŸ’» ì¶”ê°€ ê³µë¶€
### 1. ì´ë¯¸ì§€ ë°ì´í„°ì™€ í…ì„œ

#### ðŸ“Œ ì´ë¯¸ì§€ ë°ì´í„°ëž€?

- ì´ë¯¸ì§€ ë°ì´í„°ëŠ” í”½ì…€ ê°’ë“¤ì˜ ì§‘í•©ìœ¼ë¡œ êµ¬ì„± 
- ëŒ€ë¶€ë¶„ì˜ ê²½ìš°, ì´ë¯¸ì§€ ë°ì´í„°ëŠ” 2D ë°°ì—´ ë˜ëŠ” 3D ë°°ì—´ë¡œ í‘œí˜„ë˜ë©°, ê° í”½ì…€ì€ ìƒ‰ìƒì„ í‘œí˜„í•˜ëŠ” ê°’ë“¤ì„ ê°€ì§„ë‹¤. 
- ì˜ˆë¥¼ ë“¤ì–´, í‘ë°± ì´ë¯¸ì§€ëŠ” 2D ë°°ì—´ë¡œ ì €ìž¥ë˜ë©°, RGB ì»¬ëŸ¬ ì´ë¯¸ì§€ëŠ” 3D ë°°ì—´ë¡œ ì €ìž¥

- **í‘ë°± ì´ë¯¸ì§€**: ê° í”½ì…€ì€ 0ì—ì„œ 255 ì‚¬ì´ì˜ ê°’ì„ ê°€ì§€ë©°, 2D ë°°ì—´ë¡œ í‘œí˜„
- **ì»¬ëŸ¬ ì´ë¯¸ì§€**: ê° í”½ì…€ì€ 3ê°œì˜ ê°’(R, G, B)ì„ ê°€ì§€ë©°, 3D ë°°ì—´ë¡œ í‘œí˜„

>ì˜ˆë¥¼ ë“¤ì–´, 28Ã—28 í¬ê¸°ì˜ í‘ë°± ì´ë¯¸ì§€ëŠ” 28x28ì˜ 2D ë°°ì—´ë¡œ, ê° ê°’ì€ 0ì—ì„œ 255 ì‚¬ì´ì˜ í”½ì…€ ê°•ë„ë¥¼ ê°€ì§„ë‹¤.

#### ðŸ“Œ í…ì„œ(Tensor)

- í…ì„œëŠ” ë‹¤ì°¨ì› ë°°ì—´ì„ ì˜ë¯¸í•˜ë©°, íŠ¹ížˆ ë¨¸ì‹ ëŸ¬ë‹ì—ì„œëŠ” ë°ì´í„°ë¥¼ í‘œí˜„í•˜ëŠ” ë° ì‚¬ìš©. 
- PyTorchì—ì„œëŠ” í…ì„œë¥¼ `torch.Tensor`ë¡œ ë‚˜íƒ€ë‚¸ë‹¤. ì´ë¯¸ì§€ ë°ì´í„°ëŠ” í…ì„œ í˜•íƒœë¡œ ì²˜ë¦¬ë˜ëŠ” ê²½ìš°ê°€ ë§Žë‹¤.

- **ìŠ¤ì¹¼ë¼**: 0D í…ì„œ, í•˜ë‚˜ì˜ ê°’ë§Œì„ í¬í•¨.
- **ë²¡í„°**: 1D í…ì„œ, 1ì°¨ì› ë°°ì—´.
- **í–‰ë ¬**: 2D í…ì„œ, 2ì°¨ì› ë°°ì—´.
- **ë‹¤ì°¨ì› ë°°ì—´**: 3D ì´ìƒ í…ì„œ, ì˜ˆë¥¼ ë“¤ì–´ ì´ë¯¸ì§€ ë°ì´í„°ëŠ” 3D í…ì„œë¡œ í‘œí˜„ë©ë‹ˆë‹¤. (ë†’ì´, ë„ˆë¹„, ì±„ë„)

ë”°ë¼ì„œ, ì´ë¯¸ì§€ ë°ì´í„°ëŠ” ë³´í†µ `torch.Tensor` í˜•íƒœë¡œ ë³€í™˜í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ì— ìž…ë ¥ëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´, RGB ì´ë¯¸ì§€ì˜ ê²½ìš° `(ë†’ì´, ë„ˆë¹„, 3)` í˜•íƒœë¡œ í…ì„œí™”ëœë‹¤.

#### ðŸ“Œ ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ í…ì„œë¡œ ë³€í™˜í•˜ê¸°

OpenCVë¥¼ ì‚¬ìš©í•´ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ê³ , ì´ë¥¼ PyTorch í…ì„œë¡œ ë³€í™˜í•˜ëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:
```python
import cv2
import torch
import numpy as np

# ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° (OpenCVë¡œ)
image = cv2.imread('path_to_image.jpg')

# BGR -> RGBë¡œ ë³€í™˜
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# ì´ë¯¸ì§€ í¬ê¸° ì¡°ì • (ì˜µì…˜)
image = cv2.resize(image, (224, 224))

# ì´ë¯¸ì§€ë¥¼ í…ì„œë¡œ ë³€í™˜
image_tensor = torch.tensor(image).float()

# í…ì„œì˜ ì°¨ì› (Height, Width, Channels)
print(image_tensor.shape)

```

---
### 2. í™œì„±í™” í•¨ìˆ˜ (Activation Function)

#### í™œì„±í™” í•¨ìˆ˜ëž€?

- í™œì„±í™” í•¨ìˆ˜ëŠ” ì‹ ê²½ë§ì—ì„œ ë‰´ëŸ°ì˜ ì¶œë ¥ì„ ê²°ì •í•˜ëŠ” í•¨ìˆ˜ 
- ì‹ ê²½ë§ì—ì„œ ê° ì¸µì€ ìž…ë ¥ ë°ì´í„°ë¥¼ ë°›ì•„ ê°€ì¤‘ì¹˜ì™€ ë°”ì´ì–´ìŠ¤ë¥¼ ì ìš©í•œ í›„, ì´ ê°’ì„ í™œì„±í™” í•¨ìˆ˜ì— í†µê³¼ì‹œì¼œ ì¶œë ¥ ê°’ì„ ìƒì„± 
- ì´ ì¶œë ¥ ê°’ì€ ë‹¤ìŒ ì¸µì˜ ìž…ë ¥ ê°’ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤. 
- í™œì„±í™” í•¨ìˆ˜ëŠ” ë¹„ì„ í˜•ì„±ì„ ì¶”ê°€í•˜ì—¬ ëª¨ë¸ì´ ë³µìž¡í•œ í•¨ìˆ˜ë„ í•™ìŠµí•  ìˆ˜ ìžˆê²Œ í•œë‹¤.

#### **ìžì£¼ ì‚¬ìš©ë˜ëŠ” í™œì„±í™” í•¨ìˆ˜**

- **ReLU (Rectified Linear Unit)**: ìŒìˆ˜ ìž…ë ¥ì€ 0ìœ¼ë¡œ, ì–‘ìˆ˜ ìž…ë ¥ì€ ê·¸ëŒ€ë¡œ ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ìž…ë‹ˆë‹¤. í•™ìŠµ ì†ë„ê°€ ë¹ ë¥´ê³ , ìŒìˆ˜ ë¶€ë¶„ì—ì„œ ê¸°ìš¸ê¸°ê°€ 0ì´ ë˜ì–´ ì‹ ê²½ë§ í•™ìŠµì—ì„œ ë°œìƒí•  ìˆ˜ ìžˆëŠ” ë¬¸ì œì¸ "ê¸°ìš¸ê¸° ì†Œì‹¤"ì„ ì™„í™”ì‹œí‚¨ë‹¤.
    $$
    ReLU(x)= \max(0, x)\
    $$
- **Sigmoid**: ì¶œë ¥ ê°’ì´ 0ê³¼ 1 ì‚¬ì´ë¡œ ì••ì¶•ëœë‹¤. ì£¼ë¡œ ì´ì§„ ë¶„ë¥˜ ë¬¸ì œì—ì„œ ì‚¬ìš©ë¨.
    $$
    Ïƒ(x) =  \frac{1}{1 + e^{-x}}
    $$â€‹
- **Tanh**: ì¶œë ¥ ê°’ì´ -1ê³¼ 1 ì‚¬ì´ë¡œ ì••ì¶•ëœë‹¤. Sigmoidì™€ ë¹„ìŠ·í•˜ì§€ë§Œ, ì¶œë ¥ ë²”ìœ„ê°€ ë” ë„“ì–´ ì¼ë°˜ì ìœ¼ë¡œ ë” ë¹ ë¥¸ í•™ìŠµì„ ì œê³µí•œë‹¤.
    $$
    tanh(x)== \frac{2}{1 + e^{-2x}} - 1
    $$
- **Softmax**: ë‹¤ì¤‘ í´ëž˜ìŠ¤ ë¶„ë¥˜ì—ì„œ ì£¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. ì¶œë ¥ê°’ì„ í™•ë¥ ì²˜ëŸ¼ ë³€í™˜í•˜ì—¬, ê° í´ëž˜ìŠ¤ì— ëŒ€í•œ í™•ë¥ ì„ ì œê³µ

```python
# í™œì„±í™” í•¨ìˆ˜ ì˜ˆì‹œ 
import torch
import torch.nn as nn

# ReLU í™œì„±í™” í•¨ìˆ˜ ì‚¬ìš© ì˜ˆì‹œ
relu = nn.ReLU()
x = torch.tensor([-1.0, 2.0, -0.5, 3.0])
output = relu(x)
print(output)  # tensor([0., 2., 0., 3.])

```


---
### 3. ê¸°ìš¸ê¸° ì¡°ì • (Gradient Descent)

- ì‹ ê²½ë§ì€ ìž…ë ¥ ë°ì´í„°ë¥¼ í†µí•´ ì˜ˆì¸¡ì„ í•˜ê³ , ê·¸ ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œ ê°’ ì‚¬ì´ì˜ ì˜¤ì°¨ë¥¼ ê³„ì‚°í•œ ë’¤, ê·¸ ì˜¤ì°¨ë¥¼ ìµœì†Œí™”í•˜ê¸° ìœ„í•´ ê°€ì¤‘ì¹˜ì™€ ë°”ì´ì–´ìŠ¤ë¥¼ ì—…ë°ì´íŠ¸í•œë‹¤. 
- ì´ ê³¼ì •ì—ì„œ ê¸°ìš¸ê¸°(gradient)ë¥¼ ê³„ì‚°í•˜ê³ , ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°€ì¤‘ì¹˜ë¥¼ ì¡°ì •

#### ðŸ“Œ ê¸°ìš¸ê¸° í•˜ê°•ë²• (Gradient Descent)

ê¸°ìš¸ê¸° í•˜ê°•ë²•ì€ í•¨ìˆ˜ì˜ ê¸°ìš¸ê¸°ë¥¼ ê³„ì‚°í•˜ì—¬ ìµœì†Ÿê°’ì„ ì°¾ëŠ” ìµœì í™” ë°©ë²•ìž…ë‹ˆë‹¤. ê¸°ìš¸ê¸°ëŠ” í•¨ìˆ˜ì˜ ë³€í™”ìœ¨ì„ ë‚˜íƒ€ë‚´ë©°, ê¸°ìš¸ê¸°ê°€ 0ì¸ ì§€ì ì—ì„œ í•¨ìˆ˜ëŠ” ìµœì†Ÿê°’ì„ ê°€ì§ˆ ìˆ˜ ìžˆë‹¤.

**ê¸°ìš¸ê¸° í•˜ê°•ë²•**ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê¸°ë³¸ ê³µì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

$$
w=wâˆ’Î·â‹…âˆ‡L(w)
$$

- w: ê°€ì¤‘ì¹˜
- Î·: í•™ìŠµë¥ (learning rate)
- âˆ‡L(w) : ì†ì‹¤ í•¨ìˆ˜ì˜ ê¸°ìš¸ê¸°

#### ê¸°ìš¸ê¸° ì¡°ì • ì˜ˆì‹œ (PyTorch)

- PyTorchì—ì„œëŠ” ìžë™ìœ¼ë¡œ ê¸°ìš¸ê¸°ë¥¼ ê³„ì‚°í•˜ê³  ê°€ì¤‘ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ê¸°ëŠ¥ì´ ë‚´ìž¥ë˜ì–´ ìžˆë‹¤. 
  - ì˜ˆë¥¼ ë“¤ì–´, ë‹¤ìŒê³¼ ê°™ì´ ì‹ ê²½ë§ì„ ì •ì˜í•˜ê³ , ê¸°ìš¸ê¸°ë¥¼ ê³„ì‚°í•˜ê³ , ê°€ì¤‘ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìžˆë‹¤.

```python
## ê¸°ìš¸ê¸° ì¡°ì • ì˜ˆì‹œ

import torch
import torch.nn as nn
import torch.optim as optim

# ê°„ë‹¨í•œ ì‹ ê²½ë§ ëª¨ë¸ ì •ì˜
model = nn.Sequential(
    nn.Linear(2, 2),
    nn.ReLU(),
    nn.Linear(2, 1)
)

# ì†ì‹¤ í•¨ìˆ˜ì™€ ìµœì í™” ë°©ë²• ì„¤ì •
criterion = nn.MSELoss()
optimizer = optim.SGD(model.parameters(), lr=0.01)

# ë°ì´í„°
inputs = torch.tensor([[1.0, 2.0]])
target = torch.tensor([[0.0]])

# ê¸°ìš¸ê¸° ì´ˆê¸°í™”
optimizer.zero_grad()

# ëª¨ë¸ ì¶œë ¥
output = model(inputs)

# ì†ì‹¤ ê³„ì‚°
loss = criterion(output, target)

# ê¸°ìš¸ê¸° ê³„ì‚°
loss.backward()

# ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸
optimizer.step()

print("ì†ì‹¤:", loss.item())

```

---
## ðŸ’» ì‹¤ìŠµ ì˜ˆì‹œ(OpenVcì™€ PyTorchë¡œ ì´ë¯¸ì§€ ì²˜ë¦¬ ë° ê¸°ìš¸ê¸° ì¡°ì •)
```python
import cv2
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np

image = cv2.imread('image.jpg')
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
image = cv2.resize(image, (224, 224))

# 2. ì´ë¯¸ì§€ -> í…ì„œ ë³€í™˜
image_tensor = torch.tensor(image).float().permute(2, 0, 1).unsqueeze(0)  # (1, C, H, W)

# 3. ê°„ë‹¨í•œ ì‹ ê²½ë§ ëª¨ë¸ ì •ì˜
model = nn.Sequential(
    nn.Conv2d(3, 16, 3),
    nn.ReLU(),
    nn.Flatten(),
    nn.Linear(16 * 222 * 222, 10)
)

# 4. ì†ì‹¤ í•¨ìˆ˜ì™€ ìµœì í™” ë°©ë²• 
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.01)

target = torch.tensor([1])

# 6. ê¸°ìš¸ê¸° ê³„ì‚° ë° ì—…ë°ì´íŠ¸
optimizer.zero_grad()
output = model(image_tensor)
loss = criterion(output, target)
loss.backward()
optimizer.step()

print(f'ì†ì‹¤: {loss.item()}')

```

> [íŒŒì´ì¬ ë°°ìš°ê¸°](https://wikidocs.net/60034)
> 